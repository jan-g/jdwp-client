package client

import (
	"errors"
	"io"
	"reflect"
)

type Composite struct {
	SuspendPolicy SuspendPolicy // Which threads where suspended by this composite event?
	NumEvents     int           // Events in set
	Events        []VMEvent     `jdwp:"counter:NumEvents"`
	/*
		Repeated events times:
		byte	eventKind	Event kind selector
		Case VMStart - if eventKind is JDWP.EventKind.VM_START: 	Notification of initialization of a target VM. This event is received before the main thread is started and before any application code has been executed. Before this event occurs a significant amount of system code has executed and a number of system classes have been loaded. This event is always generated by the target VM, even if not explicitly requested.
		int	requestID	Request that generated event (or 0 if this event is automatically generated.
		threadID	thread	Initial thread
		Case SingleStep - if eventKind is JDWP.EventKind.SINGLE_STEP: 	Notification of step completion in the target VM. The step event is generated before the code at its location is executed.
		int	requestID	Request that generated event
		threadID	thread	Stepped thread
		location	location	Location stepped to
		Case Breakpoint - if eventKind is JDWP.EventKind.BREAKPOINT: 	Notification of a breakpoint in the target VM. The breakpoint event is generated before the code at its location is executed.
		int	requestID	Request that generated event
		threadID	thread	Thread which hit breakpoint
		location	location	Location hit
		Case MethodEntry - if eventKind is JDWP.EventKind.METHOD_ENTRY: 	Notification of a method invocation in the target VM. This event is generated before any code in the invoked method has executed. Method entry events are generated for both native and non-native methods.

		In some VMs method entry events can occur for a particular thread before its thread start event occurs if methods are called as part of the thread's initialization.
		int	requestID	Request that generated event
		threadID	thread	Thread which entered method
		location	location	The initial executable location in the method.
		Case MethodExit - if eventKind is JDWP.EventKind.METHOD_EXIT: 	Notification of a method return in the target VM. This event is generated after all code in the method has executed, but the location of this event is the last executed location in the method. Method exit events are generated for both native and non-native methods. Method exit events are not generated if the method terminates with a thrown exception.
		int	requestID	Request that generated event
		threadID	thread	Thread which exited method
		location	location	Location of exit
		Case MethodExitWithReturnValue - if eventKind is JDWP.EventKind.METHOD_EXIT_WITH_RETURN_VALUE: 	Notification of a method return in the target VM. This event is generated after all code in the method has executed, but the location of this event is the last executed location in the method. Method exit events are generated for both native and non-native methods. Method exit events are not generated if the method terminates with a thrown exception.

		Since JDWP version 1.6.
		int	requestID	Request that generated event
		threadID	thread	Thread which exited method
		location	location	Location of exit
		value	value	Value that will be returned by the method
		Case MonitorContendedEnter - if eventKind is JDWP.EventKind.MONITOR_CONTENDED_ENTER: 	Notification that a thread in the target VM is attempting to enter a monitor that is already acquired by another thread. Requires canRequestMonitorEvents capability - see CapabilitiesNew.

		Since JDWP version 1.6.
		int	requestID	Request that generated event
		threadID	thread	Thread which is trying to enter the monitor
		tagged-objectID	object	Monitor object reference
		location	location	Location of contended monitor enter
		Case MonitorContendedEntered - if eventKind is JDWP.EventKind.MONITOR_CONTENDED_ENTERED: 	Notification of a thread in the target VM is entering a monitor after waiting for it to be released by another thread. Requires canRequestMonitorEvents capability - see CapabilitiesNew.

		Since JDWP version 1.6.
		int	requestID	Request that generated event
		threadID	thread	Thread which entered monitor
		tagged-objectID	object	Monitor object reference
		location	location	Location of contended monitor enter
		Case MonitorWait - if eventKind is JDWP.EventKind.MONITOR_WAIT: 	Notification of a thread about to wait on a monitor object. Requires canRequestMonitorEvents capability - see CapabilitiesNew.

		Since JDWP version 1.6.
		int	requestID	Request that generated event
		threadID	thread	Thread which is about to wait
		tagged-objectID	object	Monitor object reference
		location	location	Location at which the wait will occur
		long	timeout	Thread wait time in milliseconds
		Case MonitorWaited - if eventKind is JDWP.EventKind.MONITOR_WAITED: 	Notification that a thread in the target VM has finished waiting on Requires canRequestMonitorEvents capability - see CapabilitiesNew. a monitor object.

		Since JDWP version 1.6.
		int	requestID	Request that generated event
		threadID	thread	Thread which waited
		tagged-objectID	object	Monitor object reference
		location	location	Location at which the wait occured
		boolean	timed_out	True if timed out
		Case Exception - if eventKind is JDWP.EventKind.EXCEPTION: 	Notification of an exception in the target VM. If the exception is thrown from a non-native method, the exception event is generated at the location where the exception is thrown. If the exception is thrown from a native method, the exception event is generated at the first non-native location reached after the exception is thrown.
		int	requestID	Request that generated event
		threadID	thread	Thread with exception
		location	location	Location of exception throw (or first non-native location after throw if thrown from a native method)
		tagged-objectID	exception	Thrown exception
		location	catchLocation	Location of catch, or 0 if not caught. An exception is considered to be caught if, at the point of the throw, the current location is dynamically enclosed in a try statement that handles the exception. (See the JVM specification for details). If there is such a try statement, the catch location is the first location in the appropriate catch clause.

		If there are native methods in the call stack at the time of the exception, there are important restrictions to note about the returned catch location. In such cases, it is not possible to predict whether an exception will be handled by some native method on the call stack. Thus, it is possible that exceptions considered uncaught here will, in fact, be handled by a native method and not cause termination of the target VM. Furthermore, it cannot be assumed that the catch location returned here will ever be reached by the throwing thread. If there is a native frame between the current location and the catch location, the exception might be handled and cleared in that native method instead.

		Note that compilers can generate try-catch blocks in some cases where they are not explicit in the source code; for example, the code generated for synchronized and finally blocks can contain implicit try-catch blocks. If such an implicitly generated try-catch is present on the call stack at the time of the throw, the exception will be considered caught even though it appears to be uncaught from examination of the source code.
		Case ThreadStart - if eventKind is JDWP.EventKind.THREAD_START: 	Notification of a new running thread in the target VM. The new thread can be the result of a call to java.lang.Thread.start or the result of attaching a new thread to the VM though JNI. The notification is generated by the new thread some time before its execution starts. Because of this timing, it is possible to receive other events for the thread before this event is received. (Notably, Method Entry Events and Method Exit Events might occur during thread initialization. It is also possible for the VirtualMachine AllThreads command to return a thread before its thread start event is received.

		Note that this event gives no information about the creation of the thread object which may have happened much earlier, depending on the VM being debugged.
		int	requestID	Request that generated event
		threadID	thread	Started thread
		Case ThreadDeath - if eventKind is JDWP.EventKind.THREAD_DEATH: 	Notification of a completed thread in the target VM. The notification is generated by the dying thread before it terminates. Because of this timing, it is possible for {@link VirtualMachine#allThreads} to return this thread after this event is received.

		Note that this event gives no information about the lifetime of the thread object. It may or may not be collected soon depending on what references exist in the target VM.
		int	requestID	Request that generated event
		threadID	thread	Ending thread
		Case ClassPrepare - if eventKind is JDWP.EventKind.CLASS_PREPARE: 	Notification of a class prepare in the target VM. See the JVM specification for a definition of class preparation. Class prepare events are not generated for primtiive classes (for example, java.lang.Integer.TYPE).
		int	requestID	Request that generated event
		threadID	thread	Preparing thread. In rare cases, this event may occur in a debugger system thread within the target VM. Debugger threads take precautions to prevent these events, but they cannot be avoided under some conditions, especially for some subclasses of java.lang.Error. If the event was generated by a debugger system thread, the value returned by this method is null, and if the requested suspend policy for the event was EVENT_THREAD all threads will be suspended instead, and the composite event's suspend policy will reflect this change.

		Note that the discussion above does not apply to system threads created by the target VM during its normal (non-debug) operation.
		byte	refTypeTag	Kind of reference type. See JDWP.TypeTag
		referenceTypeID	typeID	Type being prepared
		string	signature	Type signature
		int	status	Status of type. See JDWP.ClassStatus
		Case ClassUnload - if eventKind is JDWP.EventKind.CLASS_UNLOAD: 	Notification of a class unload in the target VM.

		There are severe constraints on the debugger back-end during garbage collection, so unload information is greatly limited.
		int	requestID	Request that generated event
		string	signature	Type signature
		Case FieldAccess - if eventKind is JDWP.EventKind.FIELD_ACCESS: 	Notification of a field access in the target VM. Field modifications are not considered field accesses. Requires canWatchFieldAccess capability - see CapabilitiesNew.
		int	requestID	Request that generated event
		threadID	thread	Accessing thread
		location	location	Location of access
		byte	refTypeTag	Kind of reference type. See JDWP.TypeTag
		referenceTypeID	typeID	Type of field
		fieldID	fieldID	Field being accessed
		tagged-objectID	object	Object being accessed (null=0 for statics
		Case FieldModification - if eventKind is JDWP.EventKind.FIELD_MODIFICATION: 	Notification of a field modification in the target VM. Requires canWatchFieldModification capability - see CapabilitiesNew.
		int	requestID	Request that generated event
		threadID	thread	Modifying thread
		location	location	Location of modify
		byte	refTypeTag	Kind of reference type. See JDWP.TypeTag
		referenceTypeID	typeID	Type of field
		fieldID	fieldID	Field being modified
		tagged-objectID	object	Object being modified (null=0 for statics
		value	valueToBe	Value to be assigned
		Case VMDeath - if eventKind is JDWP.EventKind.VM_DEATH:
		int	requestID	Request that generated event
	*/
}

type VMEvent interface {
	EventKind() EventKind
}

type EventKind uint8

const (
	EventKindSINGLE_STEP                   = EventKind(1)
	EventKindBreakpoint                    = EventKind(2)
	EventKindFRAME_POP                     = EventKind(3)
	EventKindEXCEPTION                     = EventKind(4)
	EventKindUSER_DEFINED                  = EventKind(5)
	EventKindTHREAD_START                  = EventKind(6)
	EventKindTHREAD_DEATH                  = EventKind(7)
	EventKindTHREAD_END                    = EventKind(7) // obsolete - was used in jvmdi
	EventKindCLASS_PREPARE                 = EventKind(8)
	EventKindCLASS_UNLOAD                  = EventKind(9)
	EventKindCLASS_LOAD                    = EventKind(10)
	EventKindFIELD_ACCESS                  = EventKind(20)
	EventKindFIELD_MODIFICATION            = EventKind(21)
	EventKindEXCEPTION_CATCH               = EventKind(30)
	EventKindMETHOD_ENTRY                  = EventKind(40)
	EventKindMETHOD_EXIT                   = EventKind(41)
	EventKindMETHOD_EXIT_WITH_RETURN_VALUE = EventKind(42)
	EventKindMONITOR_CONTENDED_ENTER       = EventKind(43)
	EventKindMONITOR_CONTENDED_ENTERED     = EventKind(44)
	EventKindMONITOR_WAIT                  = EventKind(45)
	EventKindMONITOR_WAITED                = EventKind(46)
	EventKindVM_START                      = EventKind(90)
	EventKindVM_INIT                       = EventKind(90) // obsolete - was used in jvmdi
	EventKindVM_DEATH                      = EventKind(99)
	EventKindVM_DISCONNECTED               = EventKind(100) // Never sent across JDWP
)

type EventBreakpoint struct {
	RequestId int      // Request that generated event
	Thread    ThreadId // Thread which hit breakpoint
	Location  Location // Location hit
}

func (*EventBreakpoint) EventKind() EventKind {
	return EventKindBreakpoint
}

func VMEventFactory(buf io.Reader, into reflect.Value) error {
	var kind EventKind
	if k, err := parseUint8(buf); err != nil {
		return err
	} else {
		kind = EventKind(k)
	}
	var val VMEvent
	switch kind {
	case EventKindBreakpoint:
		val = &EventBreakpoint{}
	default:
		return errors.New("unimplemented factory")
	}
	vv := reflect.ValueOf(val) //.Elem()
	if err := ParseBuf(buf, vv, nil, nil); err != nil {
		return err
	}
	into.Set(vv)
	return nil
}

func init() {
	RegisterFactory([]VMEvent{}, VMEventFactory)
}
